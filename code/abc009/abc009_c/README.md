## [AtCoder Beginner Contest 009_C 辞書式順序ふたたび](https://atcoder.jp/contests/abc009/tasks/abc009_3)

## 問題
まず、英小文字(`a-z`)のみからなる $N$ 文字の文字列 $S$ が与えられる。 $S=S_1, S_2, \cdots , S_N$ の文字を並び替えて作れるような文字列 $T = T_1, T_2, \cdots , T_N$ ( $T_{N!}$ の間違いか?)のうち、辞書順で最小になるようなものを求めてほしい。  
ただし、並び替え方には $1$ つだけ制限がある。別に整数 $K$ が与えられ、元から一の変わった文字の個数を $K$ 以下にしなければならない。つまり、 $S_i \ne T_i$ となるような(文字が不一致となるような) $i \ (1 \leqq i \leqq N)$ の個数が $K$ 以下であるような並べ替え方しかできない。

## 入力
入力は以下の形式で標準入力から与えられる。

$$
\begin{matrix}
N & K \\
S \\
\end{matrix}
$$

- $1$ 行目には文字列の文字数を表す整数 $N \ (1 \leqq N \leqq 100)$ と、位置を変えてよい文字数の上限を表す整数 $K \ (0 \leqq K \leqq N)$ が与えられる。
- $2$ 行目には英小文字からなる $N$ 文字の文字列が与えられる。

## 出力
$S$ の文字を並び替えて作れるような文字列で、しかも元からの位置の変わった文字の個数が $K$ 個以下であるようなもののうち、辞書式順序で最も小さくなるような文字列を $1$ 行に出力せよ。  
出力の末尾にも改行をいれること。

## 解き方
まず、すべての文字を要素として取り出し、その文字を重複を許したセットで辞書順に整理する。順に取り出し後ろに付け加えていって文字列を生成し、もとの文字と何文字入れ替えることによって得られるかを計算。残りの文字の並び替えを行ったとき、入れ替えの総和が $K$ 以下に収まっているかを判定する。  
そのために、「ある位置までの文字列が確定した際に、それより後ろの文字列と指定した文字列との差が $m$ 以下に抑えられるか？」を判定する関数が必要。
もし、この関数で $true$ 、つまり $m$ 以下に抑えられることが確定した場合は、前半の文字列は確定する。 $false$ が返ってきた場合は、そのままでは不適なので、末尾を次の文字に移す。その文字は、最初に辞書順に整理したセットから引っ張ってくるため、確定したところまでの文字は随時セットから削除する。  
以上のような貪欲法を用いて解く。

## 計算量
- 重複を許したセットの生成で $\mathcal{O}(N \log N)$
- 文字を確定させる処理に $\mathcal{O}(N)$
    - セットに残った文字を順に取り出し、その文字が確定するかを判定する $\mathcal{O}(N)$
        - 判定方法：セットに残った文字を、元の文字列の通りに並べたとき、入れ替えの総和は、文字が足りなくて並べることができなかった位置の数。その数と、確定した文字列内の文字の入れ替え数の和が $K$ 以下かを調べる $\mathcal{O}(N)$

総計算量は $\mathcal{O}(N^3)$ のオーダーで、最大で $\mathcal{O}(1.0 \times 10^6)$  


## コード
### [C++](abc009_c.cpp)