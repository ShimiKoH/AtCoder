## [AtCoder Beginner Contest 014_D 閉路](https://atcoder.jp/contests/abc014/tasks/abc014_4)

## 問題
$n$ 個の頂点と $n-1$ 本の辺からなる連結な無向グラフが与えられる。それぞれの頂点には $1$ から $n$ までの番号が順番に振られている。
グラフ理論において、このような条件を満たすグラフは木と呼ばれ、閉路を含まないという性質がある。このグラフに対し、元のグラフに含まれない追加辺 $(a,b)$ を1つ追加したグラフについて考えてみると、このグラフはちょうど1つの閉路を含む。あなたの仕事は、そのようなグラフについて、閉路の長さ(閉路に含まれる辺の数)を出力することである。ただ、追加辺の候補はいくつかあり、$Q$ 個与えられるので、それらすべての候補について答えを出力しなさい。

## 入力
入力は以下の形式で標準入力から与えられる。
```math
\begin{matrix}
N & & \\
x_i & y_1 & \\
x_2 & y_2 & \\
\vdots & & \\
x_{N-1} & y_{N-1} & \\
Q & & \\
a_1 & b_1 & \\
a_2 & b_2 & \\
\vdots & & \\
a_Q & b_Q & \\
\end{matrix}
```
- $1$ 行目には、グラフの頂点数を表す整数 $N(1 \leqq N \leqq 100,000)$ が与えられる。
- 続く $2$ 行目から $N-1$ 行は、グラフの辺情報を表す。 $i$ 番目の行には、辺が結ぶ頂点 $x_i$ と $y_i$ が空白区切りで与えられる。
- 続く $1+N$ 行目には、辺 $(a,b)$ の候補の数を表す整数 $Q(1 \leqq Q \leqq 100,000)$ が与えられる。
- 続く $2+N$ 行目から $Q$ 行は、 $i$ 番目の追加辺候補の情報を表す。 $i$ 番目の行には、追加辺が結ぶ頂点 $a_i$ と $b_i$ が空白区切りで与えられる。
- 与えられる辺は全て、存在する頂点を結んでいる。
- グラフは自己辺を含まない。つまり、任意の $i$ について、 $x_i \ne y_i$ が成り立つ。
- グラフは多重辺を含まない。つまり、任意の $i,j(i \ne j)$ について、 $x_i \ne x_j$ もしくは $y_i ne y_j$ が成り立つ。
- 追加辺は、元のグラフに含まれない辺であり、自己辺でないことが保証されている。

## 出力
すべての追加辺候補について、それをもとのグラフに追加したときにできる閉路の長さを、 $1$ 行目から $Q$ 行順番に出力せよ。

***

## 解き方
~~幅優先探索 <i>BFS (breadth first search)</i> による最短経路問題
キューに、次に訪れる頂点の番号を格納し、それとは別にスタート地点から何ステップで到達できるかの情報を格納する配列を用意する。ゴール地点に到達したときのステップ数に$1$を加えたものが、閉路の長さである。
なお、ここでいうスタート地点とは、追加辺のうちのどちらか一方、ゴール地点とはもう一方の頂点である。~~
上記の方法では最悪計算量が $\mathrm{O}(NQ)$ 、最大で $\mathcal{O}(10^{10})$ となるので遅い。

そこで、頂点 $1$ からの距離をあらかじめ求めておく。以下、頂点 $1$ からの距離を「深さ」と呼ぶことにする(それにともなって階層や浅いなどの言葉も使うがそこは各々類推していただきたい)。
スタートとゴールからそれぞれ頂点 $1$ に向かって進み、どこで同じ頂点にたどり着くかを考える。このとき、深さを合わせておかないとどちらかが先に $1$ についてしまうことがあるので、進む前に同じ深さになるまで深い方を進ませる。
- 頂点 $1$ で鉢合わせた場合は、それぞれの深さの和が答えになる。
- それ以外の場合は、それぞれの深さの和から、鉢合わせた頂点の深さの $2$ 倍を引く。

この方法では、それぞれの頂点に $1$ から向かったルートの直前の頂点を知っておく必要がある。
その履歴をたどることで前述の方法を実装できるからである。

この考えを応用すると、同じ深さに調整してから何階層上ったら同じ頂点に到達するかを、二分探索のように探すことができる。例えば、深さ $20$ の頂点から深さ $10$ まで登ったとき、
- 同じ頂点であればそこから深い位置に答えがある
- 異なる頂点であれば、それより浅い位置に答えがある。
と考えることができる。

これに必要な配列は、ある頂点から $2^k(0 \leqq k \leqq \lceil \log N \rceil)$ 登った頂点の番号を格納した $2$ 次元配列。

## 計算量
- $1$ からの距離を求めるのに、<i>BFS</i>で $\mathcal{O}(N)$ 
- 直前の頂点を取得するのは、上の処理と同時に行う。
- 与えられた追加辺について答えを導くのに、深さの調整や二分探索で $\mathcal{O}(\log^2 N)$ 
    - 二分探索そのものに、$\mathcal{O}(\log N)$ 
    - 二分探索の内部で、任意の頂点から数階層上がった頂点を求めるのに、$\mathcal{O}(\log N)$
- 与えられる追加辺は $Q$ 個

最悪計算量は $\mathcal{O}(N + Q\log^2N)$ 、最大で $\mathcal{O}(2.8\times 10^7)$ ほど。


## コード
### [C++](abc014_d.cpp)
### [C++ <span style="font-size:70%">(実行時間エラー)</span>](abc014_d_2.cpp)